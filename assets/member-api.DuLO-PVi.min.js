var d = i => {
    throw TypeError(i)
};
var m = (i, t, s) => t.has(i) || d("Cannot " + s);
var e = (i, t, s) => (m(i, t, "read from private field"), s ? s.call(i) : t.get(i)),
    u = (i, t, s) => t.has(i) ? d("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(i) : t.set(i, s),
    l = (i, t, s, n) => (m(i, t, "write to private field"), n ? n.call(i, s) : t.set(i, s), s);
import "./theme.CHt78ou0.min.js";

const g = "https://platform.smile.io/v1", p = "channel_li6VC28S28AqDkmJ3E1ug0gV";

class w {
    constructor(t) {
        this.baseURL = t
    }

    setHeaders(t) {
        this.headers = t
    }

    async fetchUrl(t, s, n = null, c = {}) {
        const h = {method: t, headers: {...this.headers || {}, ...c.headers}, body: n ? JSON.stringify(n) : null};
        h.signal = c.signal;
        const _ = this.baseURL + s;
        try {
            const a = await fetch(_, h);
            if (!a.ok) throw new Error(`HTTP error! status: ${a.status}`);
            return await a.json()
        } catch (a) {
            throw console.error("Fetch error:", a), a
        }
    }

    get(t, s = {}) {
        return this.fetchUrl("GET", t, null, s)
    }

    post(t, s, n = {}) {
        return this.fetchUrl("POST", t, s, n)
    }

    put(t, s, n = {}) {
        return this.fetchUrl("PUT", t, s, n)
    }

    delete(t, s = {}) {
        return this.fetchUrl("DELETE", t, null, s)
    }
}

var r, o;

class f {
    constructor(t = g, s = p) {
        u(this, r);
        u(this, o);
        l(this, r, new w(t)), this.channelKey = s, e(this, r).setHeaders(this.getDefaultHeaders())
    }

    getDefaultHeaders(t = "") {
        return {
            "Content-Type": "application/json",
            "Smile-Channel-Key": this.channelKey,
            "Smile-Client": "smile-ui", ...t && {Authorization: `Bearer ${t}`}
        }
    }

    async init() {
        let t = {};
        try {
            const s = await (async () => {
                const url = `https://platform.smile.io/smile_ui/init?publishableKey=pub_942aa29435118d88`;
                const res = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        'Smile-Client': 'smile-ui',
                        'X-Smile-Publishable-Key': 'pub_942aa29435118d88'

                    }
                });
                return await res.json();
            })();
            // const s = await e(this, r).get(`https://platform.smile.io/smile_ui/init?publishableKey=pub_942aa29435118d88`);
            try {
                t = JSON.parse(window.localStorage.getItem("smile_shopify_data")) || {}
            } catch (c) {
                console.error("Failed to parse localStorage data", c)
            }
            const n = await e(this, r).post("/shopify/identify_customer", t);
            return l(this, o, n.customer), this.config = s, e(this, r).setHeaders(this.getDefaultHeaders(n.auth_token)), {
                customer: e(this, o),
                config: this.config,
                api: {
                    putCustomersAsync: this.putCustomersAsync.bind(this),
                    postActivities: this.postActivities.bind(this),
                    getCustomesInfo: this.getCustomesInfo.bind(this),
                    getBestPointsProductToShow: this.getBestPointsProductToShow.bind(this),
                    getCustomerPointsProducts: this.getCustomerPointsProducts.bind(this),
                    getCustomerActivityRulesAsync: this.getCustomerActivityRulesAsync.bind(this),
                    getAllPointsProducts: this.getAllPointsProducts.bind(this),
                    fetchAllPointsPointsTransactions: this.fetchAllPointsPointsTransactions.bind(this),
                    getRewardFulfillments: this.getRewardFulfillments.bind(this),
                    purchase: this.purchase.bind(this)
                }
            }
        } catch (s) {
            throw console.error("Failed to initialize Smile API", s), s
        }
    }

    async putCustomersAsync(t) {
        return e(this, r).put(`/customers/${e(this, o).id}`, t)
    }

    async postActivities(t) {
        return await e(this, r).post(`/activities`, t)
    }

    async getCustomesInfo() {
        return e(this, r).get("/smile_ui_customers/me?include=next_vip_tier.image_svg,vip_tier.image_svg,")
    }

    async getBestPointsProductToShow() {
        return e(this, r).get(`/customers/${e(this, o).id}/best_points_product_to_show?include=reward,current_available_points_product.reward.image_svg,next_points_product.reward.image_svg`)
    }

    async getCustomerPointsProducts() {
        return e(this, r).get(`/customer_points_products/${e(this, o).id}?include=reward,customer_points_products.points_product.reward.image_svg`)
    }

    async getCustomerActivityRulesAsync(t = 10, s = "") {
        return e(this, r).get(`/customer_activity_rules?customer_id=${e(this, o).id}&include=activity_rule,image_svg,metadata&limit=${t}&cursor=${s}`)
    }

    async getAllPointsProducts(t = 10, s = "") {
        return e(this, r).get(`/customer_points_products?customer_id=${e(this, o).id}&include=reward,customer_points_products.points_product.reward.image_svg,metadata&limit=${t}&cursor=${s}`)
    }

    async fetchAllPointsPointsTransactions(t = 10, s = "") {
        return e(this, r).get(`/points_transactions?include=image_svg,source_description,instructions_html,reward,state,metadata&limit=${t}&cursor=${s}`)
    }

    async getRewardFulfillments() {
        return e(this, r).get("/reward_fulfillments?include=image_svg,source_description,instructions_html,reward,state&is_transient=false")
    }

    async purchase(t, s) {
        return e(this, r).post(`/points_products/${t}/purchase?customer_id=${e(this, o).id}&include=reward_fulfillment.image_svg,reward_fulfillment.reward,reward_fulfillment.source_description,reward_fulfillment.instructions_html`, s)
    }

    async waitForObject(t) {
        for (; typeof window[t] != "object";) await new Promise(s => setTimeout(s, 100));
        return window[t]
    }
}

r = new WeakMap, o = new WeakMap;

async function A() {
    return await new f().init()
}

export {A as i};
